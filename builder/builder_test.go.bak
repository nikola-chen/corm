func TestTableNameLengthLimit(t *testing.T) {
	// Test table name with exactly 128 characters (should pass)
	longTableName := strings.Repeat("a", 128)
	q := mysqlQB().Select("*").From(longTableName)
	_, _, err := q.SQL()
	if err != nil {
		t.Fatalf("Expected table name with 128 chars to be valid, got error: %v", err)
	}

	// Test table name with 129 characters (should fail)
	overlongTableName := strings.Repeat("b", 129)
	q2 := mysqlQB().Select("*").From(overlongTableName)
	_, _, err = q2.SQL()
	if err == nil {
		t.Fatalf("Expected table name with 129 chars to be invalid, but got no error")
	}
	if !strings.Contains(err.Error(), "exceeds maximum length of 128 characters") {
		t.Fatalf("Expected error about length limit, got: %v", err)
	}

	// Test with Update
	q3 := mysqlQB().Update(overlongTableName).Set("name", "test")
	_, _, err = q3.SQL()
	if err == nil {
		t.Fatalf("Expected table name with 129 chars to be invalid for Update, but got no error")
	}
	if !strings.Contains(err.Error(), "exceeds maximum length of 128 characters") {
		t.Fatalf("Expected error about length limit for Update, got: %v", err)
	}

	// Test with Delete
	q4 := mysqlQB().Delete(overlongTableName)
	_, _, err = q4.SQL()
	if err == nil {
		t.Fatalf("Expected table name with 129 chars to be invalid for Delete, but got no error")
	}
	if !strings.Contains(err.Error(), "exceeds maximum length of 128 characters") {
		t.Fatalf("Expected error about length limit for Delete, got: %v", err)
	}

	// Test with Insert
	q5 := mysqlQB().Insert(overlongTableName)
	_, _, err = q5.SQL()
	if err == nil {
		t.Fatalf("Expected table name with 129 chars to be invalid for Insert, but got no error")
	}
	if !strings.Contains(err.Error(), "exceeds maximum length of 128 characters") {
		t.Fatalf("Expected error about length limit for Insert, got: %v", err)
	}
}

func TestEmptyAndWhitespaceInputs(t *testing.T) {
	tests := []struct {
		name string
		fn   func() error
	}{
		{
			"empty From",
			func() error {
				_, _, err := mysqlQB().Select("*").From("").SQL()
				return err
			},
		},
		{
			"whitespace From",
			func() error {
				_, _, err := mysqlQB().Select("*").From("   ").SQL()
				return err
			},
		},
		{
			"empty Where",
			func() error {
				_, _, err := mysqlQB().Select("*").From("users").Where("").SQL()
				return err
			},
		},
		{
			"whitespace Where",
			func() error {
				_, _, err := mysqlQB().Select("*").From("users").Where("   ").SQL()
				return err
			},
		},
		{
			"empty OrderBy column",
			func() error {
				_, _, err := mysqlQB().Select("*").From("users").OrderBy("", "ASC").SQL()
				return err
			},
		},
		{
			"empty GroupBy",
			func() error {
				_, _, err := mysqlQB().Select("*").From("users").GroupBy("").SQL()
				return err
			},
		},
		{
			"empty Having",
			func() error {
				_, _, err := mysqlQB().Select("*").From("users").Having("").SQL()
				return err
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := tt.fn()
			if err == nil {
				t.Errorf("%s: expected error but got none", tt.name)
			}
		})
	}
}

func TestInvalidIdentifiers(t *testing.T) {
	invalidIdentifiers := []string{
		"table with spaces",
		"table-with-dashes",
		"table/with/slashes",
		"table;with;semicolons",
		"table\"with\"quotes",
		"table`with`backticks",
		"123startingwithnumber",
		"table.with.dots", // This should actually work as table.column format
	}

	for _, ident := range invalidIdentifiers {
		t.Run("From_"+ident, func(t *testing.T) {
			_, _, err := mysqlQB().Select("*").From(ident).SQL()
			// Skip the dot case as it's valid table.column format
			if strings.Contains(ident, ".") && !strings.HasPrefix(ident, ".") && !strings.HasSuffix(ident, ".") {
				if err != nil {
					t.Logf("Expected table.column format to work, but got error: %v", err)
				}
				return
			}
			if err == nil {
				t.Errorf("Expected error for invalid identifier: %s", ident)
			}
		})
	}
}

func TestSQLInjectionAttempts(t *testing.T) {
	// Test that dangerous inputs are properly handled
	dangerousInputs := []string{
		"users; DROP TABLE users; --",
		"users' OR '1'='1",
		"users\" OR \"1\"=\"1",
		"users` OR `1`=`1",
		"users/* comment */",
		"users-- comment",
	}

	for _, input := range dangerousInputs {
		t.Run("From_"+input, func(t *testing.T) {
			_, _, err := mysqlQB().Select("*").From(input).SQL()
			if err == nil {
				t.Errorf("Expected error for dangerous input: %s", input)
			}
		})
	}
}

func TestMaxSQLLengthExceeded(t *testing.T) {
	// This test is tricky because we can't easily trigger the SQL length limit
	// in normal usage, but we can test the validation logic indirectly
	// by creating a very complex query
	
	q := mysqlQB().Select("*").From("users")
	
	// Add many WHERE conditions
	for i := 0; i < 100; i++ {
		q = q.Where("field%d = ?", i)
	}
	
	// Add many ORDER BY clauses
	for i := 0; i < 50; i++ {
		q = q.OrderBy("field"+strconv.Itoa(i), "ASC")
	}
	
	// This should still work, but if we had a much larger query it might hit limits
	_, _, err := q.SQL()
	if err != nil {
		// If we get an error about SQL length, that's expected behavior
		if strings.Contains(err.Error(), "exceeds maximum length") {
			t.Logf("SQL length limit working as expected: %v", err)
		} else {
			t.Errorf("Unexpected error: %v", err)
		}
	}
}

func TestNilDialectHandling(t *testing.T) {
	// Test that nil dialect is handled gracefully
	api := &builder.API{}
	
	defer func() {
		if r := recover(); r != nil {
			t.Errorf("Expected no panic with nil dialect, but got: %v", r)
		}
	}()
	
	_, err := api.Select("*").From("users").SQL()
	if err == nil {
		t.Errorf("Expected error with nil dialect")
	}
}