以下是对当前仓库的二次全方位审计结论与“可落地”的修复/优化计划（以不引入第三方库为前提）。

## 发现的问题（含代码定位）
### 安全性与稳定性
- **OrderBy 的 dir 可注入/可生成非法 SQL**：当前把 `dir` 原样拼到 SQL（仅 upper/trim），若调用方传入恶意片段会直接进入 SQL。[select.go:L68-L75](file:///Users/macrochen/Codespace/AI/corm/builder/select.go#L68-L75)
- **Join/Where/Having 支持 Raw 字符串，误用风险高**：虽然支持参数化，但 Join 没有参数通道，Where/Having 也容易把用户输入拼进字符串。[select.go:L37-L66](file:///Users/macrochen/Codespace/AI/corm/builder/select.go#L37-L66)、[expr.go](file:///Users/macrochen/Codespace/AI/corm/clause/expr.go)
- **PostgreSQL `? -> $n` 重写器不完整**：对 `''` 转义、`--`/`/* */` 注释、`$$...$$` dollar-quote 等场景处理不足，可能误替换字符串/注释里的 `?` 导致语义错误。[postgres.go:L24-L70](file:///Users/macrochen/Codespace/AI/corm/dialect/postgres.go#L24-L70)
- **ScanOne(map) 缺少 key 类型校验**：`ScanAll` 有校验，但 `ScanOne` map 分支没有，可能触发 panic。[scan.go:L64-L131](file:///Users/macrochen/Codespace/AI/corm/exec/scan.go#L64-L131)

### 性能与可观测性
- **扫描与列映射仍有优化空间**：struct 扫描已改为“直接扫描到字段指针”，但仍可进一步缓存“列名->字段 index”映射、复用 holders，提升大结果集性能。[scan.go](file:///Users/macrochen/Codespace/AI/corm/exec/scan.go)
- **Engine 的 logger 目前未用于记录 SQL/耗时**：已经有 Logger 接口与配置，但执行路径未使用，排障不便。[engine.go](file:///Users/macrochen/Codespace/AI/corm/engine/engine.go)

### 易用性/一致性
- **SetModel/Record 的错误处理与顺序不稳定**：`RecordValues` 返回 map，Update 的 SetModel 迭代 map 会导致 SQL/args 顺序不稳定，影响 stmt 缓存与测试可重复性；且部分 API 对解析失败“静默忽略”，不利于定位问题。[schema.go](file:///Users/macrochen/Codespace/AI/corm/schema/schema.go)、[update.go](file:///Users/macrochen/Codespace/AI/corm/builder/update.go)
- **编码规范问题**：代码里出现了新增的注释段（与你的“不要加注释”规范冲突），需要清理。[update.go](file:///Users/macrochen/Codespace/AI/corm/builder/update.go)
- **go.mod 的 go 版本字段可疑**：`go 1.25.6` 可能导致外部用户工具链兼容问题。[go.mod](file:///Users/macrochen/Codespace/AI/corm/go.mod)

## 执行计划（我将按顺序落地并跑全量测试）
### 1) 安全加固（P0）
- 将 `OrderBy` 的方向参数收敛为白名单（仅 ASC/DESC）；提供 `OrderByAsc(col)`/`OrderByDesc(col)` 作为推荐 API，并在 README 强调不要把用户输入放进标识符/dir。
- 为 Raw API 做“显式不安全”分层：保留兼容的 `Where/Join/Having`，新增 `WhereRaw/JoinRaw/HavingRaw`（或反向：新增安全 API 如 `WhereEq/WhereIn`），并在 README 迁移推荐。
- 修复 `ScanOne` map 分支：补齐与 `ScanAll` 一致的 `map[string]T` 校验，避免 panic。

### 2) PostgreSQL 占位符策略升级（P0）
- 方案 A（优先）：**从源头生成占位符**——builder 生成 SQL 时直接调用 dialect.Placeholder(n) 输出 `$1,$2...`，不再对整段 SQL 进行字符串重写（提升正确性与性能）。
- 方案 B（保底）：完善 `RewritePlaceholders` tokenizer，正确跳过字符串/注释/dollar-quote。

### 3) Builder 错误传播与稳定性（P1）
- 给各 Builder 增加内部 error 状态：链式调用过程中一旦发生模型解析/参数问题，后续 `SQL/Exec/Query` 直接返回该错误，消除“静默失败”。
- 让 `SetModel/Record` 的列与参数顺序稳定：改为严格按 `schema.Fields` 顺序生成（不再迭代 map）。
- 增加字段策略：默认不更新主键/自动列，支持 tag 选项（如 `db:"id,pk"` + `db:",omitempty"`/`db:",readonly"`）控制“忽略零值/只读字段”。

### 4) 结果扫描进一步性能优化（P1）
- 为 struct 扫描增加“列->字段 index”缓存（key=type+columns），并用 `sync.Pool` 复用 holders，降低大结果集分配。

### 5) 可观测性与易用性（P1）
- 将 Engine/Tx 的执行路径接入 logger：可选记录 SQL、args 数量、耗时、错误；提供慢查询阈值。

### 6) 工程整理与兼容性（P2）
- 清理不符合规范的注释段（保持代码整洁）。
- 评估并调整 `go.mod` 的 `go` 版本为更通用的最低支持版本（如 1.22/1.23），并在 README 标注。
- 处理空的 `tx/` 目录（删除或补齐用途），保持目录结构一致。

我将按以上计划逐项提交变更，并在每个阶段运行 `go test ./...` 确保无回归。